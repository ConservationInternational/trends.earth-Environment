name: Tests

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12", "3.13"]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v6
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt', 'requirements-dev.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Type checking with mypy
      run: |
        mypy gefcore/ --ignore-missing-imports --no-strict-optional
      continue-on-error: true  # Type checking failures shouldn't fail the build initially
    
    - name: Security check with bandit
      run: |
        bandit -r gefcore/ -f json -o bandit-report.json || true
        bandit -r gefcore/ -ll
      continue-on-error: true  # Security issues shouldn't fail the build initially
    
    - name: pip-audit check for vulnerabilities
      run: |
        pip install pip-audit
        pip-audit --format=json --output=safety-report.json --requirement=requirements.txt || true
        pip-audit --requirement=requirements.txt || echo "pip-audit scan completed with warnings"
      continue-on-error: true  # Vulnerability checks shouldn't fail the build initially
    
    - name: Run unit tests
      run: |
        pytest tests/ -v --cov=gefcore --cov-report=xml --cov-report=term-missing
      env:
        ENV: test
        TESTING: true
        ROLLBAR_SCRIPT_TOKEN: test_token
        GOOGLE_PROJECT_ID: test_project
        GEE_ENDPOINT: https://test.example.com
        API_URL: https://test-api.example.com
        API_USER: test_user
        API_PASSWORD: test_password
        EXECUTION_ID: test_execution_id
        PARAMS_S3_BUCKET: test-bucket
        PARAMS_S3_PREFIX: test-prefix
    
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false
    
    - name: Upload test artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-reports-python-${{ matrix.python-version }}
        path: |
          htmlcov/
          bandit-report.json
          safety-report.json
          coverage.xml

  syntax-check:
    runs-on: ubuntu-latest
    name: Quick Syntax Check
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: "3.12"
    
    - name: Install minimal dependencies
      run: |
        python -m pip install --upgrade pip
        pip install ast-tools
    
    - name: Quick syntax validation
      run: |
        # Quick syntax check for all Python files
        find . -name "*.py" -not -path "./.git/*" -not -path "./__pycache__/*" -exec python -m py_compile {} \;
    
    - name: Check for duplicate function definitions
      run: |
        python -c "
        import ast
        import sys
        from pathlib import Path
        
        errors = []
        for py_file in Path('.').rglob('*.py'):
            if '.git' in str(py_file) or '__pycache__' in str(py_file):
                continue
            
            try:
                with open(py_file, 'r') as f:
                    tree = ast.parse(f.read(), filename=str(py_file))
                
                # Check for duplicate functions within each class
                for node in ast.walk(tree):
                    if isinstance(node, ast.ClassDef):
                        class_functions = {}
                        for child in node.body:
                            if isinstance(child, ast.FunctionDef):
                                if child.name in class_functions:
                                    errors.append(f'{py_file}: Duplicate function {child.name} in class {node.name} at line {child.lineno} (first at line {class_functions[child.name]})')
                                else:
                                    class_functions[child.name] = child.lineno
                
                # Check for duplicate functions at module level (not in any class)
                module_functions = {}
                for node in tree.body:
                    if isinstance(node, ast.FunctionDef):
                        if node.name in module_functions:
                            errors.append(f'{py_file}: Duplicate module-level function {node.name} at line {node.lineno} (first at line {module_functions[node.name]})')
                        else:
                            module_functions[node.name] = node.lineno
            except:
                pass
        
        if errors:
            for error in errors:
                print(f'ERROR: {error}')
            sys.exit(1)
        else:
            print('No duplicate function definitions found.')
        "

  build-test:
    runs-on: ubuntu-latest
    name: Build Test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v5
    
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: "3.12"
    
    - name: Test Docker build
      run: |
        docker build -t trends-earth-env-test .
    
    - name: Test basic import in container
      run: |
        docker run --rm \
          -e ENV=test \
          -e TESTING=true \
          trends-earth-env-test \
          python -c "import gefcore; print('Import successful')"
